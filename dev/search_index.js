var documenterSearchIndex = {"docs":
[{"location":"#CFMultigrid","page":"Home","title":"CFMultigrid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CFMultigrid.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#CFMultigrid.Param","page":"Home","title":"CFMultigrid.Param","text":"param = Param()\n\nreturns the default parameters set for the multigrid. param is mutable. All the entries can be modified.\n\nprint(param)\n\nto see all the parameters. param is the sole input argument to create a multigrid object (see ?get_gmg)\n\n\n\n\n\n","category":"type"},{"location":"#CFMultigrid.get_gmg-Tuple{Param}","page":"Home","title":"CFMultigrid.get_gmg","text":"mg = get_gmg(param)\n\nReturns a multigrid object, whose specs are defined by param (see ?Param)\n\nThe operator A is defined by param.operator. So far only the :laplacian is implemented\nTwo types of boundary conditions (BC) are possible: Dirichlet and Neumann. They are selected by setting the param.location of the discretized variables: either :vertices (for Dirichlet) or :centers (for Neumann).\n\nTo see the grid hierarchy\n\n`print(mg.levels)`\n\nTo solve A * x = b\n\n`res, nite = solve!(mg)`\n\nb, the r.h.s., must be copied in mg.data[1].b (a 3d array)\nx, the first guess and the solution, is in mg.data[1].x (a 3d array)\n\nIrregular domains are handled with a mask system. Look inside 'tests/' for examples.\n\n\n\n\n\n","category":"method"}]
}
